{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.0/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_router;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_router = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return i_router address\n  function getRouter() public view returns (address) {\n    return address(i_router);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IOwnable.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwner} from \"./ConfirmedOwner.sol\";\n\n/// @title The OwnerIsCreator contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract OwnerIsCreator is ConfirmedOwner {\n  constructor() ConfirmedOwner(msg.sender) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/IGhoToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IAccessControl} from '@openzeppelin/contracts/access/IAccessControl.sol';\n\n/**\n * @title IGhoToken\n * @author Aave\n */\ninterface IGhoToken is IERC20, IAccessControl {\n  struct Facilitator {\n    uint128 bucketCapacity;\n    uint128 bucketLevel;\n    string label;\n  }\n\n  /**\n   * @dev Emitted when a new facilitator is added\n   * @param facilitatorAddress The address of the new facilitator\n   * @param label A hashed human readable identifier for the facilitator\n   * @param bucketCapacity The initial capacity of the facilitator's bucket\n   */\n  event FacilitatorAdded(\n    address indexed facilitatorAddress,\n    bytes32 indexed label,\n    uint256 bucketCapacity\n  );\n\n  /**\n   * @dev Emitted when a facilitator is removed\n   * @param facilitatorAddress The address of the removed facilitator\n   */\n  event FacilitatorRemoved(address indexed facilitatorAddress);\n\n  /**\n   * @dev Emitted when the bucket capacity of a facilitator is updated\n   * @param facilitatorAddress The address of the facilitator whose bucket capacity is being changed\n   * @param oldCapacity The old capacity of the bucket\n   * @param newCapacity The new capacity of the bucket\n   */\n  event FacilitatorBucketCapacityUpdated(\n    address indexed facilitatorAddress,\n    uint256 oldCapacity,\n    uint256 newCapacity\n  );\n\n  /**\n   * @dev Emitted when the bucket level changed\n   * @param facilitatorAddress The address of the facilitator whose bucket level is being changed\n   * @param oldLevel The old level of the bucket\n   * @param newLevel The new level of the bucket\n   */\n  event FacilitatorBucketLevelUpdated(\n    address indexed facilitatorAddress,\n    uint256 oldLevel,\n    uint256 newLevel\n  );\n\n  /**\n   * @notice Returns the identifier of the Facilitator Manager Role\n   * @return The bytes32 id hash of the FacilitatorManager role\n   */\n  function FACILITATOR_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Bucket Manager Role\n   * @return The bytes32 id hash of the BucketManager role\n   */\n  function BUCKET_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external;\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external;\n\n  /**\n   * @notice Add the facilitator passed with the parameters to the facilitators list.\n   * @dev Only accounts with `FACILITATOR_MANAGER_ROLE` role can call this function\n   * @param facilitatorAddress The address of the facilitator to add\n   * @param facilitatorLabel A human readable identifier for the facilitator\n   * @param bucketCapacity The upward limit of GHO can be minted by the facilitator\n   */\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external;\n\n  /**\n   * @notice Remove the facilitator from the facilitators list.\n   * @dev Only accounts with `FACILITATOR_MANAGER_ROLE` role can call this function\n   * @param facilitatorAddress The address of the facilitator to remove\n   */\n  function removeFacilitator(address facilitatorAddress) external;\n\n  /**\n   * @notice Set the bucket capacity of the facilitator.\n   * @dev Only accounts with `BUCKET_MANAGER_ROLE` role can call this function\n   * @param facilitator The address of the facilitator\n   * @param newCapacity The new capacity of the bucket\n   */\n  function setFacilitatorBucketCapacity(address facilitator, uint128 newCapacity) external;\n\n  /**\n   * @notice Returns the facilitator data\n   * @param facilitator The address of the facilitator\n   * @return The facilitator configuration\n   */\n  function getFacilitator(address facilitator) external view returns (Facilitator memory);\n\n  /**\n   * @notice Returns the bucket configuration of the facilitator\n   * @param facilitator The address of the facilitator\n   * @return The capacity of the facilitator's bucket\n   * @return The level of the facilitator's bucket\n   */\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the list of the addresses of the active facilitator\n   * @return The list of the facilitators addresses\n   */\n  function getFacilitatorsList() external view returns (address[] memory);\n}"
    },
    "contracts/Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {IGhoToken} from './IGhoToken.sol';\nimport \"./IERC20.sol\";\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {OwnerIsCreator} from \"@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol\";\n\n/**\n * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.\n * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.\n * DO NOT USE THIS CODE IN PRODUCTION.\n */\n\nstruct Bucket {\n    uint256 collateral;\n    uint256 amount;\n    uint256 CollateralWorth;\n    address user;\n    bool drained;\n}\n\n/// @title - A simple contract for receiving string data across chains.\ncontract FacilitatorReceiver is CCIPReceiver, OwnerIsCreator {\n    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance.\n\n    event MessageSent(\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\n        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.\n        address receiver, // The address of the receiver on the destination chain.\n        uint256 id, // The id being sent.\n        address feeToken, // the token address used to pay CCIP fees.\n        uint256 fees // The fees paid for sending the CCIP message.\n    );\n\n    // Event emitted when a message is received from another chain.\n    event MessageReceived(\n        bytes32 indexed messageId, // The unique ID of the message.\n        uint64 indexed sourceChainSelector, // The chain selector of the source chain.\n        address sender, // The address of the sender from the source chain.\n        string text // The text that was received.\n    );\n\n    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.\n    string private s_lastReceivedText; // Store the last received text.\n\n    IGhoToken public ghoToken;\n    IERC20 public ghoErc;\n    IRouterClient private s_router;\n    LinkTokenInterface private s_linkToken;\n    AggregatorV3Interface internal dataFeed;\n    uint64 public destinationChainSelector = 16015286601757825753; //sepolia hardcoded for testing\n    address public senderVault;\n\n    uint256 bucketIndex;\n    uint256[] public activeBuckets;\n    mapping(uint256 => Bucket) public allbuckets;\n    mapping(address => uint256[]) public userBuckets;\n\n    /// @notice Constructor initializes the contract with the router address.\n    /// @param router The address of the router contract.\n    constructor(address router, address _ghoToken, address _link, address _senderVault) CCIPReceiver(router) {\n        ghoToken = IGhoToken(_ghoToken);\n        ghoErc = IERC20(_ghoToken);\n        dataFeed = AggregatorV3Interface(\n            0x007A22900a3B98143368Bd5906f8E17e9867581b  // BTC/USD mumbai\n        );\n        s_router = IRouterClient(router);\n        s_linkToken = LinkTokenInterface(_link);\n        senderVault = _senderVault;\n    }\n\n    /// handle a received message\n    function _ccipReceive(\n        Client.Any2EVMMessage memory any2EvmMessage\n    ) internal override {\n        // s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId\n        // s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text\n        // (string memory _name, uint256 _amount, address _user) = abi.decode(\n        //     any2EvmMessage.data,\n        //     (string, uint256, address)\n        // );\n\n        (string memory action, uint256 id, uint256 collateral, uint256 amount, uint256 collateralWorth, address user) = abi.decode(\n            any2EvmMessage.data,\n            (string, uint256, uint256, uint256, uint256, address)\n        );\n\n        activeBuckets.push(bucketIndex);\n        userBuckets[user].push(bucketIndex);\n        \n        allbuckets[bucketIndex++] = \n            Bucket({\n                collateral: collateral,\n                amount: amount,\n                CollateralWorth: collateralWorth,\n                user: user,\n                drained: false\n            });\n\n        ghoToken.mint(user, amount);\n\n        emit MessageReceived(\n            any2EvmMessage.messageId,\n            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)\n            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,\n            abi.decode(any2EvmMessage.data, (string))\n        );\n    }\n\n    function drain(uint256 id) public {\n        require(bucketIndex > id , \"nonexistent bucket id\");\n        Bucket storage chosenBucket =  allbuckets[id];\n        require(chosenBucket.drained == false, \"cant drain empty bucket\");\n        chosenBucket.drained = true;\n        ghoErc.transferFrom(msg.sender, address(this), chosenBucket.amount);\n        if (chosenBucket.user == msg.sender) {\n            sendMessage(senderVault, id);\n        } else {\n        uint256 collateralWorth = (uint256(getChainlinkDataFeedLatestAnswer()) * chosenBucket.collateral) / uint256(getChainlinkDecimal()) / 18;\n            require((chosenBucket.amount / 2 * 3) < collateralWorth,  \"Cant liquidate\");\n            sendMessage(senderVault, id);\n        }\n    }\n\n    function getChainlinkDecimal() public view returns (uint8) {\n        return dataFeed.decimals();\n    }\n\n    function getChainlinkDataFeedLatestAnswer() public view returns (int) {\n        // prettier-ignore\n        (\n            /* uint80 roundID */,\n            int answer,\n            /*uint startedAt*/,\n            /*uint timeStamp*/,\n            /*uint80 answeredInRound*/\n        ) = dataFeed.latestRoundData();\n        return answer;\n    }\n\n    function sendMessage(\n        address receiver,\n        uint256 id\n    ) public onlyOwner returns (bytes32 messageId) {\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\n            data: abi.encode(id, msg.sender), // ABI-encoded string\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n            extraArgs: Client._argsToBytes(\n                // Additional arguments, setting gas limit\n                Client.EVMExtraArgsV1({gasLimit: 600_000})\n            ),\n            // Set the feeToken  address, indicating LINK will be used for fees\n            feeToken: address(s_linkToken)\n        });\n\n        // Get the fee required to send the message\n        uint256 fees = s_router.getFee(\n            destinationChainSelector,\n            evm2AnyMessage\n        );\n\n        if (fees > s_linkToken.balanceOf(address(this)))\n            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);\n\n        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK\n        s_linkToken.approve(address(s_router), fees);\n\n        // Send the message through the router and store the returned message ID\n        messageId = s_router.ccipSend(destinationChainSelector, evm2AnyMessage);\n\n        // Emit an event with message details\n        emit MessageSent(\n            messageId,\n            destinationChainSelector,\n            receiver,\n            id,\n            address(s_linkToken),\n            fees\n        );\n\n        // Return the message ID\n        return messageId;\n    }\n\n    /// @notice Fetches the details of the last received message.\n    /// @return messageId The ID of the last received message.\n    /// @return text The last received text.\n    function getLastReceivedMessageDetails()\n        external\n        view\n        returns (bytes32 messageId, string memory text)\n    {\n        return (s_lastReceivedMessageId, s_lastReceivedText);\n    }\n}\n"
    },
    "contracts/Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {OwnerIsCreator} from \"@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./IERC20.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\n\n/**\n * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.\n * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.\n * DO NOT USE THIS CODE IN PRODUCTION.\n */\n\nstruct Bucket {\n    uint256 collateral;\n    uint256 amount;\n    uint256 CollateralWorth;\n    address user;\n    bool drained;\n}\n\n/// @title - A simple contract for sending string data across chains.\ncontract CollateralLockerSender is OwnerIsCreator, CCIPReceiver {\n    // Custom errors to provide more descriptive revert messages.\n    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance.\n\n    // Event emitted when a message is sent to another chain.\n    event MessageSent(\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\n        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.\n        address receiver, // The address of the receiver on the destination chain.\n        string text, // The text being sent.\n        address feeToken, // the token address used to pay CCIP fees.\n        uint256 fees // The fees paid for sending the CCIP message.\n    );\n\n    IRouterClient private s_router;\n    LinkTokenInterface private s_linkToken;\n    AggregatorV3Interface internal dataFeed;\n    IERC20 public collateralToken;\n    address public receiverFacilitator;\n    uint64 public destinationChainSelector = 12532609583862916517;\n    uint256 public protocolRewards;\n\n    Bucket[] public buckets;\n    mapping(address => uint256[]) public userBuckets;\n    mapping(address => uint256) public userBucketAmount;\n\n    /// @notice Constructor initializes the contract with the router address.\n    /// @param _router The address of the router contract.\n    /// @param _link The address of the link contract.\n    constructor(address _router, address _link, address _collateralToken, address _receiverFacilitator) CCIPReceiver(_router) {\n        s_router = IRouterClient(_router);\n        s_linkToken = LinkTokenInterface(_link);\n        dataFeed = AggregatorV3Interface(\n            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43\n        );\n        collateralToken = IERC20(_collateralToken);\n        receiverFacilitator = _receiverFacilitator;\n    }\n\n    function _ccipReceive(\n        Client.Any2EVMMessage memory any2EvmMessage\n    ) internal override {\n        (uint256 id, address user) = abi.decode(\n            any2EvmMessage.data,\n            (uint256, address)\n        );\n\n        Bucket storage chosenBucket =  buckets[id];\n        chosenBucket.drained = true;\n        collateralToken.transfer(user, chosenBucket.collateral / 100 * 99);\n        protocolRewards += chosenBucket.collateral / 100;\n    }\n\n    function deposit(uint256 _collateral, uint256 _amount) public {\n        collateralToken.transferFrom(msg.sender, address(this), _collateral);\n        uint256 collateralWorth = (uint256(getChainlinkDataFeedLatestAnswer()) * _collateral) / uint256(getChainlinkDecimal()) / 18;\n        require((collateralWorth / 2) >= _amount , \"low collateral\");\n        require(collateralWorth != 0 || _amount != 0 , \"low collateral\");\n\n        sendMessage(receiverFacilitator, \"DEPOSIT\", _collateral, _amount, collateralWorth, buckets.length);\n        userBuckets[msg.sender].push(buckets.length);\n        userBucketAmount[msg.sender]++;\n        buckets.push(\n            Bucket({\n                collateral: _collateral,\n                amount: _amount,\n                CollateralWorth: collateralWorth,\n                user: msg.sender,\n                drained: false\n            })\n                );\n    }\n\n    function getCurrentCollateralWorth(uint256 _collateral) public view returns (uint256) {\n        return (uint256(getChainlinkDataFeedLatestAnswer()) * _collateral) / uint256(getChainlinkDecimal()) / 18;\n    }\n\n    function getChainlinkDecimal() public view returns (uint8) {\n        return dataFeed.decimals();\n    }\n\n    function getChainlinkDataFeedLatestAnswer() public view returns (int) {\n        // prettier-ignore\n        (\n            /* uint80 roundID */,\n            int answer,\n            /*uint startedAt*/,\n            /*uint timeStamp*/,\n            /*uint80 answeredInRound*/\n        ) = dataFeed.latestRoundData();\n        return answer;\n    }\n\n    /// @notice Sends data to receiver on the destination chain.\n    /// @dev Assumes your contract has sufficient LINK.\n    /// @param receiver The address of the recipient on the destination blockchain.\n    /// @param text The string text to be sent.\n    /// @return messageId The ID of the message that was sent.\n    function sendMessage(\n        address receiver,\n        string memory text,\n        uint256 collateral,\n        uint256 amount,\n        uint256 collateralWorth,\n        uint256 id\n    ) public onlyOwner returns (bytes32 messageId) {\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\n            data: abi.encode(text, id, collateral, amount, collateralWorth, msg.sender), // ABI-encoded string\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n            extraArgs: Client._argsToBytes(\n                // Additional arguments, setting gas limit\n                Client.EVMExtraArgsV1({gasLimit: 900_000})\n            ),\n            // Set the feeToken  address, indicating LINK will be used for fees\n            feeToken: address(s_linkToken)\n        });\n\n        // Get the fee required to send the message\n        uint256 fees = s_router.getFee(\n            destinationChainSelector,\n            evm2AnyMessage\n        );\n\n        if (fees > s_linkToken.balanceOf(address(this)))\n            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);\n\n        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK\n        s_linkToken.approve(address(s_router), fees);\n\n        // Send the message through the router and store the returned message ID\n        messageId = s_router.ccipSend(destinationChainSelector, evm2AnyMessage);\n\n        // Emit an event with message details\n        emit MessageSent(\n            messageId,\n            destinationChainSelector,\n            receiver,\n            text,\n            address(s_linkToken),\n            fees\n        );\n\n        // Return the message ID\n        return messageId;\n    }\n\n    function withdrawRewards() public onlyOwner {\n        collateralToken.transfer(msg.sender, protocolRewards);\n        protocolRewards = 0;\n    }\n\n    function setFacilitator(address _receiverFacilitator) public onlyOwner {\n        receiverFacilitator = _receiverFacilitator;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}